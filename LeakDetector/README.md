# LeakDetector 内存泄漏检查器

- LeakDetector.h: 定义了内存泄漏检查器的类和一个该类的静态对象，该对象在程序结束时进行析构，在析构函数中调用我们的内存泄漏检查函数进行检查
- LeakDetector.cpp: 实现了基于双向链表的内存分配和释放功能，重载了new和delete运算符
- main.cpp: 模拟了常见的两种内存泄漏方式，在程序结束后进行泄漏检测，并将检测结果打印

这里设计的是一个短期的内存泄露检查器，内存泄露通常是因为用户忘记释放内存，或因为异常导致程序无法执行到释放内存的语句。<br>

想要实现内存泄露检查器，就要手动对内存进行管理，因为需要重载new和delete操作符（这里说法不准确，补充知识里面进行了解释），同时我们创建一个静态对象，该对象只有在程序退出的才调用它的析构函数，利用这个特性，我们可以对整个程序中的内存泄露情况进行检查，而且无需修改原始代码。<br>

在实现时，我们使用一个动态结构双向链表来对内存进行管理，链表中的节点存储两部分内容，一部分是节点头信息，如保存pre和next指针，另一部分是实际分配给用户使用的内存。当用户使用new运算符时，检查器生成一个内存块（只能使用malloc操作）作为节点加入到链表中，当用户使用delete运算符时，检查器根据传来的指针计算出所属内存块的实际地址，并将其从链表中删除，并释放内存（只能使用free操作）。这样，当程序结束后，只需要检查链表中是否还存在内容即可知道是否发生了泄露。

## 补充知识
- new 与 operator new()
前者者是运算符，后者是函数，原型为void* ::operator new (size_t size)。<br>
new操作符的可以执行过程分为3步：1）调用operator new分配内存；2）调用构造函数生成类对象；3）返回指向该类对象的指针。<br>
如果要实现不同的内存分配方式，就需要重载operator new()函数，因此上述的重载new和delete操作符的说法是不正确的；对该函数的重载分为全局重载和类重载，其中默认的全局operator new()函数也是调用malloc进行分配的，并且返回void* 指针，而构造函数的调用是在new操作符中完成的

- __FILE__ 和 __LINE__
在我们的试验中，我们打印了内存泄露发生的文件名和语句的行数，这是如何做到的呢？<br>
实际上，系统为我们提供__FILE__和__LINE__两个宏，同时operator new()的重载是可以有自定义参数的，因此很容易就可以想到我们将两个宏传入到重载函数中记录下来就可以了。不过此时我们还需要定义一个宏，即#define new new(__FILE__, __LINE__)，然后对operator new进行重载即可
