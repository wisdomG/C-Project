# MemoryPool 内存池

- MemoryPool.h: 内存池的实现
- StackAlloc.h: 使用链表模拟一个栈，方便我们比较默认的内存分配方法和基于内存器的内存分配方法
- main.cpp: 两种内存分配方式的模拟和比较

内存池是池化技术的一种，当频繁使用new，delete操作符让操作系统从堆中分配或释放内存，就会形成大量的内存碎片，进而降低内存分配的性能，甚至出现内存分配失败的情况。
<br>
内存池就是解决上述问题的技术，如果一开始就确定需要多少内存并分配好，当某个时刻需要内存时，就从已经分配好的内存中使用即可，无需频繁的与操作系统打交道。<br>
内存池设计的基本思路是：首先我们分配好一个较大的内存块，当需要为一个对象进行内存分配时，直接从当前内存块依次取用即可（代码中称为对象槽或内存槽），如果当前内存块不够用了，则再新建一个内存块。简单理解，内存块就像一个大柜子，而对象槽就是一个个抽屉。
<br>
为了能够回收内存，当一个对象被释放后，我们将该对象所在的槽加入到一个链表（代码中新释放的内存槽作为链表头部）中进行管理。此时当需要为一个对象分配内存时，就要先看这个链表头是不是空，不为空则说明有之前释放的内存槽可以重新分配和利用，为空则按照正常流程在内存块的空闲区域以此分配。
<br>
当然，多个内存块之间也要用链表管理起来，最后统一释放。因为内存块既要存储指向前一个内存块的指针信息，又要存储类对象，因此代码中使用了union联合体

## 补充知识
- placement new <br>
也是对operator new的一个重载，使用方法为new (p) A()，其中p是一个指针，A()是构造函数（可以有参数），该语句表示在指针p所指向的位置构造一个类对象，这在我们的内存池实现中有重要作用。
